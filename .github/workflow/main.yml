name: CI/CD Pipeline for Docker

# 1. Triggers the workflow on every push to the main branch
on:
  push:
    branches: [ "main" ]

jobs:
  build-and-push:
    # Use an Ubuntu environment to run the steps
    runs-on: ubuntu-latest
    
    # Define environment variables for the job
    env:
      REGISTRY: docker.io
      IMAGE_NAME: ${{ secrets.DOCKER_USERNAME }}/project-app # Use your Docker Hub username
      
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4 # Get the code from the repository
        
      # 1. Log in to Docker Hub (or any container registry)
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }} # Fetches username from GitHub Secrets
          password: ${{ secrets.DOCKER_PASSWORD }} # Fetches token from GitHub Secrets

      # 2. Get the short git commit hash to use as a unique image tag
      - name: Extract commit tag
        id: meta
        run: |
          echo "tag=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
      
      # 3. Build the Docker Image
      # The build uses your existing Dockerfile (now with Alpine!)
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest # Tag with 'latest'
            ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.tag }} # Tag with a unique commit hash
            
      # 4. Optional: Deployment Step (Example Placeholder)
      # This step would typically trigger your production server (e.g., Kubernetes, EC2) 
      # to pull the new image tag.
      - name: Deploy to Production Server
        run: echo "Deployment triggered for image ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.tag }}"
        # In a real setup, this would use a tool like ssh, kubectl, or a cloud CLI